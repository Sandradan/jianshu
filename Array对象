## 属性
`constructor`
    指定创建对象原型的函数。

`index`
    如果数组是通过正则表达式匹配创建的，比配是字符串的下标索引为0.

`input`
    如果数组是通过正则表达式匹配创建的，返回原始的字符串。

`length长度`
    返回数组中元素个数.

`prototype`
    允许为所有对象附加属性.
***
## 方法：改变数组自身
`pop`
    移除数组的最后一个元素，返回值是被删除的元素。

`push`
    在数组的末尾添加一个或者多个元素，返回值是新的数组的长度。

`reverse`
    颠倒数组中元素的顺序，原先第一个元素现在变成最后一个，同样原先的最后一个元素变成了现在的第一个，也就是数组的索引发生了变化。

`shift`
    删除数组的第一个元素，返回值是删除的元素。

`sort`
    对数组中的元素进行排序。

`splice`
    添加或删除数组中的一个或多个元素。

`unshift`
    添加一个或者多个元素在数组的开头，返回值是新的数组的长度。

## Accessor 方法：不改变数组自身
`concat`
    返回一个包含此数组和其他数组和/或值的结合的新数组

`indexOf`
    返回第一个与给定参数相等的数组元素的索引，没有找到则返回-1。

`join`
    将所有的数组元素连接成一个字符串。

`lastIndexOf`
    返回在数组中搜索到的与给定参数相等的元素的最后（最大）索引。

`slice`
    返回数组中的一段。

`toSource`
    Returns an array literal representing the specified array; you can use this value to create a new array. Overrides the Object.toSource method.

`toString`
    返回代表该数组及其元素的字符,重写Object.toString 过程.

`valueOf`
    Returns the primitive value of the array. Overrides the Object.valueOf method.
##循环迭代
`filter`
    对数组中的每一个元素调用参数中指定的过滤函数，并将对于过滤函数返回值为true的那些数组元素集合为新的数组返回。

`forEach`
    对数组的每一个元素依次调用参数中指定的函数。

`every`
    如果数组中每一个元素都满足参数中提供的测试函数，则返回真。

`map`
    Creates a new array with the results of calling a provided function on every element in this array.

`some`
 如果数组中至少有一个元素满足参数函数的测试，则返回true。
##总结
改变原数组的方法：pop()、push()、reverse()、shift()、sort()、splice()、unshift()

不改变原数组的方法：concat()、join()、slice()、toString()


`


[[toc]]

## 实现add(1)(2)(3)

\`\`\`js
function curryFn(...args){
    return function(){
        if(arguments.length!==0){
            return curryFn(...args.concat(Array.from(arguments)))
        }
        return args.reduce((sum,cur)=>sum+cur)
    }
}
\`\`\`

## 实现有并行限制的promise调度器

\`\`\`js
class Scheduler {
    constructor(limit) {
        this.task = []
        this.maxCount = limit
        this.countNum = 0
    }

    addTask(time, value) {
        const p = () => {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    console.log(value);
                    resolve(value)
                }, time)
            })
        }
        this.task.push(p)
    }

    taskStart() {
        for (let i = 0; i < this.task.length; i++) {
            this.request()
        }
    }

    request() {
        if (!this.task || !this.task.length || this.countNum >= this.maxCount) {
            return
        }
        this.countNum++
        this.task
            .shift()()
            .then(() => {
                this.countNum--;
                this.request()
            })
    }
}

const scheduler = new Scheduler(2)

scheduler.addTask(1000, "1")
scheduler.addTask(300, "2")
scheduler.addTask(500, "3")
scheduler.addTask(100, "4")

scheduler.taskStart()
\`\`\`

`
